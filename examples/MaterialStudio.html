<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}

			#profilerDiv {
				position: absolute;
				top: 0px; width: 100%;
				color: #00ffff;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
			}
		</style>
	</head>
	<body>

		<div id="profilerDiv">
		</div>

		<script src="../build/three.js"></script>
		<script src="../src/renderers/webgl/WebGLProfiler.js"></script>
    <script src="js/lights/RectAreaLightUniformsLib.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
		<script src="js/pmrem/PMREMGenerator.js"></script>
		<script src="js/pmrem/PMREMCubeUVPacker.js"></script>
		<script src="js/pmrem/AreaLightTextureFilter.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>
		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/LuminosityHighPassShader.js"></script>
		<script src="js/postprocessing/UnrealBloomPass.js"></script>

		<script>

			var camera, scene, renderer, controls;
			var pmremGenerator, pmremCubeUvPacker;
			var cubeCamera;
			var reflectionUpdateCount = 0;
			var sceneMaterials = [];
			var allLoaded = false;

      var roomWidth = 40, roomLength = 40, roomHeight = 28;
			var wallTileHeight = roomHeight;

			var profilerDiv = document.getElementById("profilerDiv");
			var floorMaterial;

			var manager = new THREE.LoadingManager();
			manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
				console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
			};

			manager.onLoad = function ( ) {
				allLoaded = true;
			};


			manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
				console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
			};

			manager.onError = function ( url ) {
				console.log( 'There was an error loading ' + url );
			};

			var loader = new THREE.TextureLoader(manager);

			init();
			animate();

			function addShape( shape, x, y, z, rx, ry, rz, s ) {
				// var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var geometry = new THREE.PlaneBufferGeometry( 15, 20, 0.2 );
				testMesh = new THREE.Mesh( geometry );
				testMesh.position.set( x, y, z );
				testMesh.rotation.set( rx, ry, rz );
				testMesh.scale.set( s, s, s );
				scene.add( testMesh );
				return testMesh;
			}

			function createTestObject() {

				let material = new THREE.MeshStandardMaterial({ roughness: 0.2} );
				material.extensions = { shaderTextureLOD: true };
				sceneMaterials.push( material );

				let y = 1;
				let n = 5;
				for( let i=0; i< n; i++ ) {
					let mesh = addShape( material, 0, y, 0, -Math.PI/2, 0, 0, 1 );
					mesh.name = "Test" + i;
					mesh.material = floorMaterial.clone();
					mesh.material.extensions = { shaderTextureLOD: true };
					y += 0.5
				}

				// load a resource
				// loader.load(
				// 	'textures/seamless-wood-texture-free-35.jpg',
				// 	function ( texture ) {
				// 		material.map = texture;
				// 		material.bumpMap = texture;
				// 		material.bumpScale = 0.002;
				// 		material.needsUpdate = true;
				// 	},
				// 	function ( xhr ) {
				// 		console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				// 	},
				// 	function ( xhr ) {
				// 		console.log( 'An error happened' );
				// 	}
				// );

				// load a resource
				// loader.load(
				// 	'textures/Texture-normal-map26-crepi.jpg',
				// 	function ( texture ) {
				// 		material.normalMap = texture;
				// 		material.normalScale = new THREE.Vector2(0.02,0.02);
				// 		texture.wrapS = THREE.RepeatWrapping;
				// 		texture.wrapT = THREE.RepeatWrapping;
				// 		texture.repeat.set( 4, 4 );
				// 		material.needsUpdate = true;
				// 	},
				// 	function ( xhr ) {
				// 		console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				// 	},
				// 	function ( xhr ) {
				// 		console.log( 'An error happened' );
				// 	}
				// );
			}

      function createRoom() {
        let planeGeometry = new THREE.PlaneBufferGeometry( 1, 1 );
				let boxGeometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
        let wallMaterial = new THREE.MeshStandardMaterial({roughness:1.0});
				wallMaterial.extensions = { shaderTextureLOD: true };
        floorMaterial = new THREE.MeshStandardMaterial({roughness:0.30});
				floorMaterial.extensions = { shaderTextureLOD: true };
				let tileMaterial = new THREE.MeshStandardMaterial({roughness:0.4});
				tileMaterial.extensions = { shaderTextureLOD: true };
				sceneMaterials.push(wallMaterial);
				sceneMaterials.push(floorMaterial);
				sceneMaterials.push(tileMaterial);

				let floor = new THREE.Mesh( planeGeometry, floorMaterial );
				floor.name = "Floor";
        floor.scale.set(roomWidth, roomLength, 1);
        floor.rotation.x = -Math.PI/2;
        var roomRoot = new THREE.Object3D();
        // roomRoot.add(floor);

				let roof = new THREE.Mesh( planeGeometry, wallMaterial );
        roof.scale.set(roomWidth, roomLength, 1);
        roof.rotation.x = Math.PI/2;
				roof.position.y = roomHeight;
        // roomRoot.add(roof);

        let leftWall = new THREE.Mesh( planeGeometry, tileMaterial );
        leftWall.scale.set(roomWidth, roomHeight, 1);
        leftWall.rotation.y = Math.PI/2;
        leftWall.position.x = -roomWidth/2;
        leftWall.position.y = roomHeight/2;
        // roomRoot.add(leftWall);

				// let leftTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // leftTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
        // leftTileWall.rotation.y = Math.PI/2;
        // leftTileWall.position.x = -roomWidth/2;
        // leftTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(leftTileWall);

        let rightWall = new THREE.Mesh( planeGeometry, tileMaterial );
        rightWall.scale.set(roomWidth, roomHeight, 1);
        rightWall.rotation.y = -Math.PI/2;
        rightWall.position.x = roomWidth/2;
        rightWall.position.y = roomHeight/2;
        // roomRoot.add(rightWall);

				// let rightTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // rightTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
        // rightTileWall.rotation.y = -Math.PI/2;
        // rightTileWall.position.x = roomWidth/2;
        // rightTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(rightTileWall);

        let backWall = new THREE.Mesh( planeGeometry, wallMaterial );
        backWall.scale.set(roomWidth, roomHeight, 1);
				backWall.position.z = -roomWidth/2;
        backWall.position.y = roomHeight/2;
        // roomRoot.add(backWall);

				// let backTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // backTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
				// backTileWall.position.z = -roomWidth/2;
        // backTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(backTileWall);

        scene.add(roomRoot);

				// load a resource
				// loader.load(
				// 	'textures/floor-tiles-texture.jpg',
				// 	function ( texture ) {
				// 		floorMaterial.map = texture;
				// 		floorMaterial.bumpMap = texture;
				// 		floorMaterial.bumpScale = 0.07;
				// 		floorMaterial.needsUpdate = true;
				// 	},
				// 	function ( xhr ) {
				// 		console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				// 	},
				// 	function ( xhr ) {
				// 		console.log( 'An error happened' );
				// 	}
				// );
				// Load Wall Tiles Texture
				loader.load(
					'textures/tile2.jpg',
					function ( texture ) {
						ratio = roomHeight/wallTileHeight;
						tileMaterial.map = texture;
						tileMaterial.bumpMap = texture;
						tileMaterial.bumpScale = 0.03;
						tileMaterial.needsUpdate = true;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4/ratio );
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);

				loader.load(
					'textures/wall_texture.jpg',
					function ( texture ) {
						wallMaterial.map = texture;
						wallMaterial.bumpMap = texture;
						wallMaterial.bumpScale = 0.003;
						wallMaterial.needsUpdate = true;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4 );
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
      }

      function setupRoom() {
        rectLight = new THREE.RectAreaLight( 0xffffff, 100, 10, 10 );
				rectLight.position.set( 15, 20, 10 );
				rectLight.lookAt( new THREE.Vector3(0, 5, 0) );
				rectLightHelper1 = new THREE.RectAreaLightHelper( rectLight );
				rectLight.add( rectLightHelper1 );
        scene.add( rectLight );

				rectLight = new THREE.RectAreaLight( 0xffffff, 100, 10, 10 );
				rectLight.position.set( -15, 20, 10 );
				rectLight.lookAt( new THREE.Vector3(0, 5, 0) );
				rectLightHelper2 = new THREE.RectAreaLightHelper( rectLight );
				rectLight.add( rectLightHelper2 );
        scene.add( rectLight );

				rectLight = new THREE.RectAreaLight( 0xffaa22, 700, 20, 20 );
				rectLight.position.set( 0, 30, 0 );
				rectLight.lookAt( new THREE.Vector3(0, 0, 0) );
				rectLightHelper3 = new THREE.RectAreaLightHelper( rectLight );
				rectLight.add( rectLightHelper3 );
        scene.add( rectLight );

				// load a resource
				loader.load(
					// resource URL
					'textures/Window_Mask.jpg',
					// Function when resource is loaded
					function ( texture ) {
						texture.flipY = false;
						rectLight.areaTexture = texture;
						rectLight.areaTexture.needsUpdate = true;
						areaLightTextureFilter = new THREE.AreaLightTextureFilter(texture);
						rectLight.areaTexture = areaLightTextureFilter.createFilteredTexture(renderer);
						rectLightHelper3.children[0].material.map = rectLight.areaTexture;
						rectLightHelper3.children[1].material.map = rectLight.areaTexture;
						rectLightHelper3.children[0].material.needsUpdate = true;
						rectLightHelper3.children[1].material.needsUpdate = true;
					},
					// Function called when download progresses
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// Function called when download errors
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
      }

			function disableGlossiness() {
				for( let i=0; i<sceneMaterials.length; i++) {
					let oldValue = sceneMaterials[i].roughness;
					sceneMaterials[i].roughness = 1.0;
					sceneMaterials[i].oldValue = oldValue;
				}
			}

			function restoreGlossiness() {
				for( let i=0; i<sceneMaterials.length; i++) {
					let oldValue = sceneMaterials[i].oldValue;
					sceneMaterials[i].roughness = oldValue;
				}
			}

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				// camera.position.z = 30;
        camera.position.y = 8;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
				// renderer.sortObjects = false;
        renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;
        renderer.toneMapping = THREE.Uncharted2ToneMapping;
        renderer.toneMappingWhitePoint = 10;
        renderer.toneMappingExposure = 5;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				document.body.appendChild( profilerDiv );

			  profiler = new THREE.WebGLProfiler(renderer);

				renderScene = new THREE.RenderPass(scene, camera);

		    // renderScene.clear = true;
		    effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
		    effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );

				var copyShader = new THREE.ShaderPass(THREE.CopyShader);
				copyShader.renderToScreen = true;

		    bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.99);//1.0, 9, 0.5, 512);
				composer = new THREE.EffectComposer(renderer);
		    composer.setSize(window.innerWidth, window.innerHeight);
		    composer.addPass(renderScene);
				// composer.addPass(effectFXAA);
		    // composer.addPass(bloomPass);
				composer.addPass(copyShader);

        controls = new THREE.OrbitControls( camera, renderer.domElement );
				//
        createRoom();
        setupRoom();
				createTestObject();

				window.addEventListener( 'resize', onWindowResize, false );

				cubeCamera = new THREE.CubeCamera( 1, 100000, 256 );
				scene.add( cubeCamera );
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function updateSceneEnvMap( envMap ) {
				for( let i=0; i<sceneMaterials.length; i++) {
					sceneMaterials[i].envMap = envMap;
					sceneMaterials[i].needsUpdate = true;
				}
			}

			function animate() {
				requestAnimationFrame( animate );

				if( !allLoaded )
					return;

        controls.update();
        rectLightHelper1.update();
				rectLightHelper2.update();
				rectLightHelper3.update();

				profiler.start();

				composer.render();

				profiler.end();

				if( profiler.available() ) {
					profilerDiv.innerHTML = Number(profiler.value()).toFixed(2) + " ms";
				}
				if( reflectionUpdateCount < 3 ) {
					// renderer.autoClear = false;
					rectLightHelper1.visible = false;
					rectLightHelper2.visible = false;
					rectLightHelper3.visible = false;
					disableGlossiness();
					cubeCamera.position.copy( new THREE.Vector3(0, roomHeight/2, 0) );
					cubeCamera.updateCubeMap( renderer, scene );
					updateCubemap = false;
					var cubeMap = cubeCamera.renderTarget;
					cubeMap.encoding = THREE.LinearEncoding;
					var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
					pmremGenerator.update( renderer );
					restoreGlossiness();
					rectLightHelper1.visible = true;
					rectLightHelper2.visible = true;
					rectLightHelper3.visible = true;
					reflectionUpdateCount++;
				}
				if( pmremGenerator !== undefined )
					updateSceneEnvMap(pmremGenerator.readCubeTextureWithLOD(renderer));

			}

		</script>

	</body>
</html>
