<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="../build/three.js"></script>
		<script src="../src/renderers/webgl/WebGLProfiler.js"></script>
    <script src="js/lights/RectAreaLightUniformsLib.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
		<script src="js/pmrem/PMREMGenerator.js"></script>
		<script src="js/pmrem/PMREMCubeUVPacker.js"></script>
		<script src="js/pmrem/AreaLightTextureFilter.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>
		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/LuminosityHighPassShader.js"></script>
		<script src="js/postprocessing/UnrealBloomPass.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>

		<script>

			var camera, scene, renderer, controls;
			var pmremGenerator, pmremCubeUvPacker;
			var cubeCamera;
			var reflectionUpdateCount = 0;
			var sceneMaterials = [];
			var allLoaded = false;

      var roomWidth = 40, roomLength = 40, roomHeight = 28;
			var wallTileHeight = roomHeight;

			var luminousFluxIndoor1 = 0; // Total Power
			var luminousFluxIndoor2 = 10; // Total Power
			var luminousFluxOutDoor = 0; // Total Power
			var rectLight1, rectLight2, rectLight3;

			var manager = new THREE.LoadingManager();
			manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
				console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
			};

			manager.onLoad = function ( ) {
				allLoaded = true;
			};


			manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
				console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
			};

			manager.onError = function ( url ) {
				console.log( 'There was an error loading ' + url );
			};

			var loader = new THREE.TextureLoader(manager);

			init();
			animate();

			function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {
				// flat shape with texture
				// note: default UVs generated by ShapeBufferGemoetry are simply the x- and y-coordinates of the vertices
				// var geometry = new THREE.ShapeBufferGeometry( shape );
				// var mesh = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial( { side: THREE.DoubleSide } ) );
				// mesh.position.set( x, y, z - 175 );
				// mesh.rotation.set( rx, ry, rz );
				// mesh.scale.set( s, s, s );
				// group.add( mesh );
				// // flat shape
				// var geometry = new THREE.ShapeBufferGeometry( shape );
				// var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
				// mesh.position.set( x, y, z - 125 );
				// mesh.rotation.set( rx, ry, rz );
				// mesh.scale.set( s, s, s );
				// group.add( mesh );
				// extruded shape
				let material = new THREE.MeshStandardMaterial({ roughness: 0.2} );
				material.extensions = { shaderTextureLOD: true };
				sceneMaterials.push( material );
				// var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var geometry = new THREE.BoxGeometry( 15, 20, 0.5 );
				testMesh = new THREE.Mesh( geometry, material );
				testMesh.position.set( x, y, z );
				testMesh.rotation.set( rx, ry, rz );
				testMesh.scale.set( s, s, s );
				scene.add( testMesh );

				// load a resource
				loader.load(
					'textures/seamless-wood-texture-free-35.jpg',
					function ( texture ) {
						material.map = texture;
						material.bumpMap = texture;
						material.bumpScale = 0.002;
						material.needsUpdate = true;
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);

				// load a resource
				loader.load(
					'textures/Texture-normal-map26-crepi.jpg',
					function ( texture ) {
						material.normalMap = texture;
						material.normalScale = new THREE.Vector2(0.02,0.02);
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4 );
						material.needsUpdate = true;
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
			}

			function createTestObject() {
				let rectWidth = 20;
				let rectLength = 15;
				var rectShape = new THREE.Shape();
				rectShape.moveTo( 0, 0 );
				rectShape.lineTo( 0, rectWidth );
				rectShape.lineTo( rectLength, rectWidth );
				rectShape.lineTo( rectLength, 0 );
				rectShape.lineTo( 0, 0 );
				var extrudeSettings = { amount: 0.5, bevelEnabled: true, bevelSegments: 12, steps: 2, bevelSize: 0.3, bevelThickness: 0.1 };
				addShape( rectShape, extrudeSettings, 0x008000, 0, 10, 0, 0, 0, 0, 1 );
			}

      function createRoom() {
        let planeGeometry = new THREE.PlaneBufferGeometry( 1, 1 );
				let boxGeometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
        let wallMaterial = new THREE.MeshStandardMaterial({roughness:1.0});
				wallMaterial.extensions = { shaderTextureLOD: true };
        let floorMaterial = new THREE.MeshStandardMaterial({roughness:0.30});
				floorMaterial.extensions = { shaderTextureLOD: true };
				let tileMaterial = new THREE.MeshStandardMaterial({roughness:0.4});
				tileMaterial.extensions = { shaderTextureLOD: true };
				sceneMaterials.push(wallMaterial);
				sceneMaterials.push(floorMaterial);
				sceneMaterials.push(tileMaterial);

				let floor = new THREE.Mesh( planeGeometry, floorMaterial );
        floor.scale.set(roomWidth, roomLength, 1);
        floor.rotation.x = -Math.PI/2;
        var roomRoot = new THREE.Object3D();
        roomRoot.add(floor);

				let roof = new THREE.Mesh( planeGeometry, wallMaterial );
        roof.scale.set(roomWidth, roomLength, 1);
        roof.rotation.x = Math.PI/2;
				roof.position.y = roomHeight;
        roomRoot.add(roof);

        let leftWall = new THREE.Mesh( planeGeometry, tileMaterial );
        leftWall.scale.set(roomWidth, roomHeight, 1);
        leftWall.rotation.y = Math.PI/2;
        leftWall.position.x = -roomWidth/2;
        leftWall.position.y = roomHeight/2;
        roomRoot.add(leftWall);

				// let leftTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // leftTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
        // leftTileWall.rotation.y = Math.PI/2;
        // leftTileWall.position.x = -roomWidth/2;
        // leftTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(leftTileWall);

        let rightWall = new THREE.Mesh( planeGeometry, tileMaterial );
        rightWall.scale.set(roomWidth, roomHeight, 1);
        rightWall.rotation.y = -Math.PI/2;
        rightWall.position.x = roomWidth/2;
        rightWall.position.y = roomHeight/2;
        roomRoot.add(rightWall);

				// let rightTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // rightTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
        // rightTileWall.rotation.y = -Math.PI/2;
        // rightTileWall.position.x = roomWidth/2;
        // rightTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(rightTileWall);

        let backWall = new THREE.Mesh( planeGeometry, wallMaterial );
        backWall.scale.set(roomWidth, roomHeight, 1);
				backWall.position.z = -roomWidth/2;
        backWall.position.y = roomHeight/2;
        roomRoot.add(backWall);

				// let backTileWall = new THREE.Mesh( boxGeometry, tileMaterial );
        // backTileWall.scale.set(roomWidth, wallTileHeight, 0.1);
				// backTileWall.position.z = -roomWidth/2;
        // backTileWall.position.y = wallTileHeight/2;
        // roomRoot.add(backTileWall);

        scene.add(roomRoot);

				// load a resource
				loader.load(
					'textures/floor-tiles-texture.jpg',
					function ( texture ) {
						floorMaterial.map = texture;
						floorMaterial.bumpMap = texture;
						floorMaterial.bumpScale = 0.07;
						floorMaterial.needsUpdate = true;
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
				// Load Wall Tiles Texture
				loader.load(
					'textures/tile2.jpg',
					function ( texture ) {
						ratio = roomHeight/wallTileHeight;
						tileMaterial.map = texture;
						tileMaterial.bumpMap = texture;
						tileMaterial.bumpScale = 0.03;
						tileMaterial.needsUpdate = true;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4/ratio );
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);

				loader.load(
					'textures/wall_texture.jpg',
					function ( texture ) {
						wallMaterial.map = texture;
						wallMaterial.bumpMap = texture;
						wallMaterial.bumpScale = 0.003;
						wallMaterial.needsUpdate = true;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4 );
					},
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
      }

      function setupRoom() {
        rectLight1 = new THREE.RectAreaLight( 0xffffff, luminousFluxIndoor1, 10, 10 );
				rectLight1.position.set( 0, 25, -10 );
				rectLight1.lookAt( new THREE.Vector3(0, 0, -10) );
				rectLightHelper1 = new THREE.RectAreaLightHelper( rectLight1 );
				rectLight1.add( rectLightHelper1 );
        scene.add( rectLight1 );

				rectLight2 = new THREE.RectAreaLight( 0xffffff, luminousFluxIndoor2, 10, 10 );
				rectLight2.position.set( 0, 25, 10 );
				rectLight2.lookAt( new THREE.Vector3(0, 0, 10) );
				rectLightHelper2 = new THREE.RectAreaLightHelper( rectLight2 );
				rectLight2.add( rectLightHelper2 );
        scene.add( rectLight2 );

				rectLight3 = new THREE.RectAreaLight( 0xffaa22, luminousFluxOutDoor, 20, 20 );
				rectLight3.position.set( 0, 10, 20 );
				rectLight3.lookAt( new THREE.Vector3(0, 10, 0) );
				rectLightHelper3 = new THREE.RectAreaLightHelper( rectLight3 );
				rectLight3.add( rectLightHelper3 );
        scene.add( rectLight3 );

				renderer.toneMappingWhitePoint = 0.5 * (luminousFluxIndoor1 + luminousFluxIndoor2 + luminousFluxOutDoor );
				// load a resource
				loader.load(
					// resource URL
					'textures/Window_Mask.jpg',
					// Function when resource is loaded
					function ( texture ) {
						texture.flipY = false;
						rectLight3.areaTexture = texture;
						rectLight3.areaTexture.needsUpdate = true;
						areaLightTextureFilter = new THREE.AreaLightTextureFilter(texture);
						rectLight3.areaTexture = areaLightTextureFilter.createFilteredTexture(renderer);
						rectLightHelper3.children[0].material.map = rectLight3.areaTexture;
						rectLightHelper3.children[1].material.map = rectLight3.areaTexture;
						rectLightHelper3.children[0].material.needsUpdate = true;
						rectLightHelper3.children[1].material.needsUpdate = true;
					},
					// Function called when download progresses
					function ( xhr ) {
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// Function called when download errors
					function ( xhr ) {
						console.log( 'An error happened' );
					}
				);
      }

			function disableGlossiness() {
				for( let i=0; i<sceneMaterials.length; i++) {
					let oldValue = sceneMaterials[i].roughness;
					sceneMaterials[i].roughness = 1.0;
					sceneMaterials[i].oldValue = oldValue;
				}
			}

			function restoreGlossiness() {
				for( let i=0; i<sceneMaterials.length; i++) {
					let oldValue = sceneMaterials[i].oldValue;
					sceneMaterials[i].roughness = oldValue;
				}
			}

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 30;
        camera.position.y = 30;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer();
        renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;
        renderer.toneMapping = THREE.Uncharted2ToneMapping;
        renderer.toneMappingWhitePoint = 40;
        renderer.toneMappingExposure = 1;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				renderScene = new THREE.RenderPass(scene, camera);

		    // renderScene.clear = true;
		    effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
		    effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );

				var copyShader = new THREE.ShaderPass(THREE.CopyShader);
				copyShader.renderToScreen = true;

		    bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 1.0, 0.99);//1.0, 9, 0.5, 512);
				composer = new THREE.EffectComposer(renderer);
		    composer.setSize(window.innerWidth, window.innerHeight);
		    composer.addPass(renderScene);
				composer.addPass(effectFXAA);
		    composer.addPass(bloomPass);
				composer.addPass(copyShader);

        controls = new THREE.OrbitControls( camera, renderer.domElement );
				//
        createRoom();
        setupRoom();
				createTestObject();

				window.addEventListener( 'resize', onWindowResize, false );

				cubeCamera = new THREE.CubeCamera( 1, 100000, 256 );
				scene.add( cubeCamera );

				var gui = new dat.GUI();

				var params = {
					Flux1: luminousFluxIndoor1,
					Flux2: luminousFluxIndoor2,
					Flux3: luminousFluxOutDoor
				}

				function changeLuminiousFlux(index, flux) {
					if( index === 0) {
						luminousFluxIndoor1 = flux;
						rectLight1.intensity = flux;
					}
					if( index === 1) {
						luminousFluxIndoor2 = flux;
						rectLight2.intensity = flux;
					}
					if( index === 2) {
						luminousFluxOutDoor = flux;
						rectLight3.intensity = flux;
					}
					renderer.toneMappingWhitePoint = 100.5 * (luminousFluxIndoor1 + luminousFluxIndoor2 + luminousFluxOutDoor );
					renderer.toneMappingWhitePoint = Math.max( renderer.toneMappingWhitePoint, 1 );
				}

				gui.add( params, "Flux1", 0, 1000, 1.0 ).onChange( changeLuminiousFlux.bind(this, 0) );
				gui.add( params, "Flux2", 0, 1000, 1.0 ).onChange( changeLuminiousFlux.bind(this, 1) );
				gui.add( params, "Flux3", 0, 1000, 1.0 ).onChange( changeLuminiousFlux.bind(this, 2) );
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function updateSceneEnvMap( envMap ) {
				for( let i=0; i<sceneMaterials.length; i++) {
					sceneMaterials[i].envMap = envMap;
					sceneMaterials[i].needsUpdate = true;
				}
			}

			function animate() {
				requestAnimationFrame( animate );

				if( !allLoaded )
					return;

        controls.update();
        rectLightHelper1.update();
				rectLightHelper2.update();
				rectLightHelper3.update();

				if(this.profiler === undefined){
					this.profiler = new THREE.WebGLProfiler(renderer);
				}
				this.profiler.start();

				composer.render();

				this.profiler.end();

				if( this.profiler.available() ) {
						console.log( this.profiler.value() );
				}

				if( reflectionUpdateCount < 3 ) {
					// renderer.autoClear = false;
					rectLightHelper1.visible = false;
					rectLightHelper2.visible = false;
					rectLightHelper3.visible = false;
					disableGlossiness();
					cubeCamera.position.copy( new THREE.Vector3(0, roomHeight/2, 0) );
					cubeCamera.updateCubeMap( renderer, scene );
					updateCubemap = false;
					var cubeMap = cubeCamera.renderTarget;
					cubeMap.encoding = THREE.LinearEncoding;
					var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
					pmremGenerator.update( renderer );
					restoreGlossiness();
					rectLightHelper1.visible = true;
					rectLightHelper2.visible = true;
					rectLightHelper3.visible = true;
					reflectionUpdateCount++;
				}
				if( pmremGenerator !== undefined )
					updateSceneEnvMap(pmremGenerator.readCubeTextureWithLOD(renderer));

			}

		</script>

	</body>
</html>
