<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #888888;
				font-family:Monospace;
				font-size:13px;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px;
				width: 200px;
				left: calc(50% - 100px);
				text-align: center;
			}

			a {
				color: #00f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - mirror
		</div>

		<script src="../build/three.js"></script>
		<script src="../examples/js/libs/stats.min.js"></script>
		<script src="js/loaders/ColladaLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/FlyControls.js"></script>
		<script src="js/pmrem/PMREMGenerator.js"></script>
		<script src="js/pmrem/PMREMCubeUVPacker.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/SAOShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>
		<!-- <script src="js/shaders/CompositeShader.js"></script> -->
    <script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/shaders/SMAAShader.js"></script>
		<script src="js/postprocessing/SMAAPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/LuminosityHighPassShader.js"></script>
		<script src="js/postprocessing/UnrealBloomPass.js"></script>
		<script src="js/Half.js"></script>
		<script src="js/utils/PoissonDiskGenerator.js"></script>
    <script src="js/postprocessing/SAOPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/ProgressiveShadowPass.js"></script>
		<script src="js/postprocessing/FilteredESM.js"></script>
		<script src="js/postprocessing/SuperSamplePass.js"></script>

		<script>

		var stats = new Stats();
		var saoPass;
		var superSamplePass = new THREE.SuperSamplePass();
		var progressiveShadowPass;
		var filteredESM;

		stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
		document.body.appendChild( stats.dom );
			// scene size
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			// camera
			var VIEW_ANGLE = 45;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 1;
			var FAR = 500;

			var camera, scene, renderer;
			var numProbes = 1;
			var probePositions = [new THREE.Vector3(0, 40, 0), new THREE.Vector3(0, 45, 0)];
			var probes = [];

			var cubeCamera;
			var updateCubemap = true;
			var updateCount = 0;
			var planeLeft, planeRight, planeTop, planeBottom, planeBack, planeFront;
			var boxMesh1, boxMesh2;
			var graniteMesh1, graniteMesh2;
			var graniteMeshes = [];
			var shMeshes = [];
			var handleMeshes = [];
			var skirtMeshes = [];
			var hobBlackMesh, hobChromeMesh;
			var sinkMesh;
			var toolMeshes = [];
			var bowlSetMeshes = [];
			var plateSetMeshes = [];
			var sphMeshes = [];

			var carMeshes = [];
			var chimneyBlackMesh, chimneyChromeMesh;
			var composer, fxaa;

			var graniteMaterial;
			var shMaterial;
			var handleMaterial;
			var skirtMaterial;
			var hobBlackMaterial, hobChromeMaterial;
			var sinkMaterial;
			var toolMaterial;
			var bowlMaterial;
			var sofaMaterial;
			sofaMaterial = new THREE.MeshStandardMaterial({color:0xffffee, roughness:0.5});

			var carMaterial;
			var chimneyBlackMaterial, chimneyChromeMaterial;

			var rootNode = new THREE.Object3D();

			var cameraControls;
			var specialMaterial = new THREE.ShaderMaterial( {

				uniforms: {
	        "shadowBuffer" : { value: null },
	        "saoBuffer"   : { value: null },
	        "lightPosition": { value: new THREE.Vector3() },
					"windowSize" : { value: new THREE.Vector2() }
				},

	      vertexShader: "varying vec3 normalEyeSpace;\
	      varying vec3 lightVector;\
	      uniform vec3 lightPosition;\
	      void main() {\
	        normalEyeSpace = normalize(normalMatrix * normal);\
	        vec3 lightPositionEyeSpace = (viewMatrix * vec4(lightPosition, 1.0)).xyz;\
	        lightVector = lightPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;\
	        lightVector = normalize(lightVector);\
	        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
	      }",

	      fragmentShader: "#include <packing>\
	        varying vec3 normalEyeSpace;\
	        varying vec3 lightVector;\
	        uniform vec2 windowSize;\
	        uniform sampler2D shadowBuffer;\
					uniform sampler2D saoBuffer;\
	        void main() {\
	          float NdotL = max(dot( normalize(normalEyeSpace), normalize(lightVector)), 0.0);\
	          float shadowValue = unpackRGBAToDepth(texture2D( shadowBuffer, gl_FragCoord.xy/windowSize));\
						float saoValue = texture2D( saoBuffer, gl_FragCoord.xy/windowSize).r;\
	          gl_FragColor = vec4(saoValue);\
	        }",
	    } );

			var verticalMirror, groundMirror;
			var sphereGroup, smallSphere;
			var allLoaded = false;
			var roughnessMap;

			var poissonSampler = new PoissonDiskGenerator(30, -1, false, false);
		  var supersamplePositions = this.poissonSampler.generatePoints();

			this.sceneOrtho = new THREE.Scene();
		  this.orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -0.001, 1000);
		  var geometry = new THREE.PlaneGeometry( 2, 2, 1, 1 );
		  var material = new THREE.MeshBasicMaterial( {color: 0xffffff, side: THREE.DoubleSide} );
		  var plane = new THREE.Mesh( geometry, specialMaterial );
		  this.sceneOrtho.add(plane);

			var manager = new THREE.LoadingManager();
			manager.onProgress = function ( item, loaded, total ) {
				console.log( item, loaded, total );
			};

			manager.onLoad = function ( ) {
				console.log( "All Items Loaded" );
				allLoaded = true;
			};

			var modelLoader = new THREE.OBJLoader();

			function init() {

				// renderer
				renderer = new THREE.WebGLRenderer({antialias : false});
				renderer.shadowMap.type = THREE.BasicShadowMap;
				// renderer.shadowMap.enabled = true;
				// ReinhardToneMapping: 2,
				// Uncharted2ToneMapping: 3, // John Hable
				// CineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson

				renderer.toneMapping = THREE.Uncharted2ToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.toneMappingWhitePoint = 1;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );
				renderer.setClearColor(0xffffff);
				// scene
				scene = new THREE.Scene();
				scene.add(rootNode);
				var radius = 8;
				var sphGeometry = new THREE.TorusGeometry(radius,radius/4, 20, 20);
				var y = 0;
				for( var i=0; i<5; i++) {
				  sphMeshes[i] = new THREE.Mesh(sphGeometry, new THREE.MeshStandardMaterial({color:0xffffff}));
					//sphMesh.position.z = -10;
					//sphMesh.position.x = 10;
					sphMeshes[i].position.y = y;
					sphMeshes[i].rotation.y = 1.5;
					// rootNode.add(sphMeshes[i]);
					y += radius*2;
				}

				loadModels();
				// camera
				camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
				camera.position.set( 0, 75, 70 );
				saoPass = new THREE.SAOPass( scene, camera );
				progressiveShadowPass = new ProgressiveShadowPass(scene, camera);

				specialMaterial.uniforms["windowSize"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 40, 0);
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.update();

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				window.addEventListener("mousedown", onMouseDown);
				window.addEventListener("mouseup", onMouseUp);
				window.addEventListener("mousemove", onMouseMove);
				container.addEventListener("mousewheel", onMouseWheel);
				renderer.domElement.addEventListener("mousewheel", onMouseWheel);

				renderPass = new THREE.RenderPass( scene, camera );
				var bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
				bloomPass.clear = false;
				fxaa = new THREE.ShaderPass( THREE.CopyShader );
				// fxaa.needsSwap = true;
				smaaPass = new THREE.SMAAPass( window.innerWidth, window.innerHeight );
				// fxaa.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );

				fxaa.renderToScreen = true;
				smaaPass.renderToScreen = true;
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderPass );
				// composer.addPass( bloomPass );
				composer.addPass( superSamplePass );
				// composer.addPass( fxaa );
			}

			var isMouseDown = false;
			function onMouseDown() {
				isMouseDown = true;
			}
			function onMouseUp() {
				isMouseDown = false;
			}
			function onMouseWheel() {
				saoPass.frameCount = 1;
				saoPass.currentFrameCount = 1;
				progressiveShadowPass.frameCount = 0;
				filteredESM.frameCount = 0;
				superSamplePass.frameCount = 0;
				temp = 0;
				frameCount = 0;
			}
			function onMouseMove() {
				if( isMouseDown ) {
					saoPass.frameCount = 1;
					saoPass.currentFrameCount = 1;
					progressiveShadowPass.frameCount = 0;
					filteredESM.frameCount = 0;
					superSamplePass.frameCount = 0;
					temp = 0;
					frameCount = 0;
				}
			}

			function IdentifyAndAddMeshes(mesh) {
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				IdentifyAndAddGraniteTopMeshes(mesh);
				IdentifyAndAddSHMeshes(mesh);
				IdentifyAndAddHandleMeshes(mesh);
				IdentifyAndAddSkirtMeshes(mesh);
				IdentifyAndAddHobMeshes(mesh);
				IdentifyAndAddSinkMesh(mesh);

				IdentifyAndAddCarMeshes(mesh);
				IdentifyAndAddChimneyMeshes(mesh);
			}

			function IdentifyAndAddGraniteTopMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("ctop") ) {
					graniteMeshes.push(mesh);
				}
			}

			function IdentifyAndAddSHMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_sh_") || name.includes("_dr_") ) {
					shMeshes.push(mesh);
				}
			}

			function IdentifyAndAddCarMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_car") || name.includes("_cur") ) {
					carMeshes.push(mesh);
				}
			}

			function IdentifyAndAddChimneyMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_chimneyblack") ) {
					chimneyBlackMesh = mesh;
				}
				if( name.includes("_chimney_chrome") ) {
					chimneyChromeMesh = mesh;
				}
			}

			function IdentifyAndAddHandleMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_handle_") ) {
					handleMeshes.push(mesh);
				}
			}

			function IdentifyAndAddSkirtMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_skirt_") || name.includes("_skirting_") ) {
					skirtMeshes.push(mesh);
				}
			}

			function IdentifyAndAddHobMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_hob_black") ) {
					hobBlackMesh = mesh;
				}
				if( name.includes("_hob_chrome") ) {
					hobChromeMesh = mesh;
				}
			}

			function IdentifyAndAddSinkMesh(mesh) {
				var name = mesh.name;
				if( name.includes("_sink_") ) {
					sinkMesh = mesh;
				}
			}

			function loadModels() {
				rootNode.position.x = 44;
				rootNode.position.z = 0.2;

				var dae;
				var daeLoader = new THREE.ColladaLoader();
				daeLoader.options.convertUpAxis = true;
				daeLoader.load( 'models/obj/Model_KitchenLShape/poliform_soho_sofa_s3.dae', function ( collada ) {
					dae = collada.scene;
					dae.traverse( function ( child ) {
						if( child instanceof THREE.Mesh ) {
							child.material = sofaMaterial;
						}
					} );
					// rootNode.add(dae);
					dae.scale.x = dae.scale.y = dae.scale.z = 10;
					dae.updateMatrix();
					// init();
					// animate();
				} );

				modelLoader.load(
					'models/obj/Model_KitchenLShape/Kitchen tools_01.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( function(mesh) {
							if( mesh instanceof THREE.Mesh ) {
								toolMeshes.push(mesh);
								mesh.castShadow = true;
								mesh.receiveShadow = true;
							}
						} );
						object.scale.x = object.scale.y = object.scale.z = 0.03;
						object.position.y = 50;
						object.position.z = -59.4;
						object.position.x = -25;
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/Bowl_set_00.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( function(mesh) {
							if( mesh instanceof THREE.Mesh ) {
								bowlSetMeshes.push(mesh);
								mesh.castShadow = true;
								mesh.receiveShadow = true;
							}
						} );
						object.scale.x = object.scale.y = object.scale.z = 0.03;
						object.position.y = 34.7;
						object.position.z = -45;
						object.position.x = -75;
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/Plates_00.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( function(mesh) {
							if( mesh instanceof THREE.Mesh ) {
								plateSetMeshes.push(mesh);
								mesh.castShadow = true;
								mesh.receiveShadow = true;
							}
						} );
						object.scale.x = object.scale.y = object.scale.z = 0.06;
						object.position.y = 39.7;
						object.position.z = -57.5;
						object.position.x = -75;
						object.rotation.x = Math.PI/2.5;
						object1 = object.clone();
						object1.position.x += 80;
						rootNode.add( object1 );
						object1.traverse( function(mesh) {
							if( mesh instanceof THREE.Mesh ) {
								plateSetMeshes.push(mesh);
								mesh.castShadow = true;
								mesh.receiveShadow = true;
							}
						} );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_clean_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_clean_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_consumable_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_consumable_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_cook_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_cook_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_non consumable_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_non consumable_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_prep_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_prep_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);
			}

			function fillScene() {

				var planeGeo = new THREE.PlaneBufferGeometry( 1.0, 1.0 );

				var loader = new THREE.TextureLoader(manager);
			  roughnessMap = loader.load("textures/leather_roughness.png");
			  var wallTexture1 = loader.load("textures/Blanc Rose Lakhsass.jpg");
				wallTexture1.wrapS = THREE.RepeatWrapping;
				wallTexture1.wrapT = THREE.RepeatWrapping;

				roughnessMap.wrapS = THREE.RepeatWrapping;
				roughnessMap.wrapT = THREE.RepeatWrapping;
				sofaMaterial.roughnessMap = roughnessMap;
				sofaMaterial.bumpMap = roughnessMap;
				roughnessMap.repeat.set( 4, 4 );
				roughnessMap.generateMipmaps = true;

				sofaMaterial.bumpScale = 0.02;

				var wallTexture2 = loader.load("textures/5096.jpg");
				var floorTexture = loader.load("textures/kitchen-tile-texture-seamless.jpg");
				var wallTexture3 = loader.load("textures/Pink wall paint stucco plaster texture tileable.jpg");
				var ceilingTexture = loader.load("textures/tilable_wall.jpg");
				var graniteTexture = loader.load("textures/marble-tiles-500x500.jpg");
				// var graniteTexture = loader.load("textures/granite.jpg");
				// var graniteTexture = loader.load("textures/marble-tiles-500x500.jpg");
				var cupboardTexture = loader.load("textures/10592 MR+ Orchard Delight.jpg");

				floorTexture.wrapS = THREE.RepeatWrapping;
				floorTexture.wrapT = THREE.RepeatWrapping;
				floorTexture.repeat.set( 3, 2 );
				floorTexture.anisotropy = 4;

				wallTexture2.wrapS = THREE.RepeatWrapping;
				wallTexture2.wrapT = THREE.RepeatWrapping;
				wallTexture2.repeat.set( 3, 2 );

				wallTexture3.wrapS = THREE.RepeatWrapping;
				wallTexture3.wrapT = THREE.RepeatWrapping;
				wallTexture3.repeat.set( 3, 2 );

				ceilingTexture.wrapS = THREE.RepeatWrapping;
				ceilingTexture.wrapT = THREE.RepeatWrapping;
				ceilingTexture.repeat.set( 4.5, 3 );

				// walls
				var roomwidth = 132;
				var roomlength = 118.5;
				var roomHeight = 100;

				graniteTexture.wrapS = THREE.RepeatWrapping;
				graniteTexture.wrapT = THREE.RepeatWrapping;
				graniteTexture.repeat.set( 1, 1 );

				cupboardTexture.wrapS = THREE.RepeatWrapping;
				cupboardTexture.wrapT = THREE.RepeatWrapping;
				// cupboardTexture.repeat.set( 6, 1 );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;

				wallTexture1.repeat.set( 3 * roomwidth/roomlength, 3 );

			  planeTop = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap:ceilingTexture, metalness:0.0, bumpScale:0.1, roughness:0.75 } ) );
				planeTop.position.y = roomHeight;
				// planeTop.position.x = roomHeight/1;
				planeTop.rotateX( Math.PI / 2 );
				planeTop.scale.x = roomwidth;
				planeTop.scale.y = roomlength;
				planeTop.castShadow = true;
				planeTop.receiveShadow = true;
				scene.add( planeTop );

			  planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map: floorTexture, bumpMap: floorTexture, bumpScale:0.1, roughness: 0.2 } ) );
				planeBottom.position.y = 0;
				planeBottom.rotateX( -Math.PI / 2 );
				planeBottom.scale.x = roomwidth;
				planeBottom.scale.y = roomlength;
				scene.add( planeBottom );
				planeBottom.castShadow = true;
				planeBottom.receiveShadow = true;

			  planeBack = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:wallTexture1, bumpMap:wallTexture1, bumpScale:0.001, roughness: 0.01} ) );
				planeBack.position.z = -roomlength/2;
				planeBack.position.y = roomHeight/2;
				planeBack.scale.x = roomwidth;
				planeBack.scale.y = roomHeight;
				planeBack.castShadow = true;
				planeBack.receiveShadow = true;
				// planeBack.material.side = THREE.DoubleSide;
				scene.add( planeBack );

			  planeFront = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:wallTexture1, bumpMap:wallTexture1, bumpScale:0.1, roughness: 0.1 } ) );
				planeFront.position.z = roomlength/2;
				planeFront.position.y = roomHeight/2;
				planeFront.rotateY( Math.PI );
				planeFront.scale.x = roomwidth;
				planeFront.scale.y = roomHeight;
				planeFront.castShadow = true;
				planeFront.receiveShadow = true;
				scene.add( planeFront );

			  planeRight = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap: ceilingTexture, bumpScale:0.03, roughness:0.75 } ) );
				planeRight.position.x = roomwidth/2;
				planeRight.position.y = roomHeight/2;
				planeRight.rotateY( - Math.PI / 2 );
				planeRight.scale.x = roomlength;
				planeRight.scale.y = roomHeight;
				planeRight.castShadow = true;
				planeRight.receiveShadow = true;
				scene.add( planeRight );

			  planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap: ceilingTexture, bumpScale:0.03,roughness:0.75  } ) );
				planeLeft.position.x = -roomwidth/2;
				planeLeft.position.y = roomHeight/2;
				planeLeft.rotateY( Math.PI / 2 );
				planeLeft.scale.x = roomlength;
				planeLeft.scale.y = roomHeight;
				planeLeft.castShadow = true;
				planeLeft.receiveShadow = true;
				// planeLeft.material.side = THREE.DoubleSide;
				scene.add( planeLeft );

				var graniteThickness = 2;
				var graniteWidth = 24.1;
				var boxHeight = 32.5;
				var boxGeometry = new THREE.BoxGeometry(roomwidth, 23.5, 14 );
				boxMesh1 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0x330000, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2  } ) );
				boxMesh1.position.z = -52.5;
				boxMesh1.position.y = 67;
				boxMesh1.castShadow = true;
				boxMesh1.receiveShadow = true;
				// scene.add( boxMesh1 );

				var boxGeometry = new THREE.BoxGeometry(roomwidth, graniteThickness, graniteWidth );
				graniteMesh1 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05  } ) );
				graniteMesh1.position.z = -roomlength/2 + graniteWidth/2;
				graniteMesh1.position.y = (boxHeight - graniteThickness) + graniteThickness/2;
				graniteMesh1.castShadow = true;
				graniteMesh1.receiveShadow = true;
				// scene.add( graniteMesh1 );

				var boxGeometry = new THREE.BoxGeometry(roomlength, boxHeight - graniteThickness, graniteWidth );
				boxMesh2 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0x330000, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2  } ) );
				boxMesh2.position.y = (boxHeight - graniteThickness)/2;
				boxMesh2.rotation.y = Math.PI/2;
				boxMesh2.position.x = -roomwidth/2 + graniteWidth/2;
				boxMesh2.position.z = 0;
				// scene.add( boxMesh2 );

				var boxGeometry = new THREE.BoxGeometry(roomlength, graniteThickness, graniteWidth );
				graniteMesh2 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05  } ) );
				graniteMesh2.rotation.y = Math.PI/2;
				graniteMesh2.position.x = -roomwidth/2 + graniteWidth/2;
				graniteMesh2.position.y = (boxHeight - graniteThickness) + graniteThickness/2;
				graniteMesh2.position.z = 0;
				// scene.add( graniteMesh2 );

			  graniteMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05, metalness:0.0  } );
				shMaterial = new THREE.MeshStandardMaterial( { color: 0x888888, metalness:0,map:cupboardTexture, bumpMap: null, bumpScale:0.0, roughness:0.02, metalness:0.0  } );
				handleMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.1, metalness: 1.0  } );
				skirtMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: graniteTexture, bumpScale:0.30, roughness:0.95, metalness: 0.0  } );
				hobBlackMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: null, bumpScale:0.0, roughness:0.05, metalness: 0.0  } );
				hobChromeMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness: 1.0  } );
				toolMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.03, metalness: 1.0  } );
				sinkMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.1, metalness: 1.0  } );
				bowlMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.05, metalness: 0.0  } );

				carMaterial = new THREE.MeshStandardMaterial( { color: 0xaaaaaa, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness:0.0  } );
				chimneyBlackMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: null, bumpScale:0.0, roughness:0.05, metalness: 0.0  } );
				chimneyChromeMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness: 1.0  } );

				// var boxHeight = roomHeight/4;
				// var boxWidth = roomHeight/4;
				// var boxGeometry = new THREE.BoxGeometry(roomwidth, boxHeight, graniteWidth );
				// boxMesh3 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:cupboardTexture, bumpScale:0.0, roughness:0.0  } ) );
				// boxMesh3.position.z = -roomlength/2 + graniteWidth/2;
				// boxMesh3.position.y = boxHeight/2;
				// boxMesh3.castShadow = true;
				// boxMesh3.receiveShadow = true;
				// // scene.add( boxMesh3 );

				// lights
				var mainLight = new THREE.SpotLight( 0xcccccc, 0.5, 200, 1.5 );
				mainLight.castShadow = true;
				mainLight.position.y = 1*roomHeight/1.5;
				// mainLight.position.z = 1*roomlength/1.2;
				// scene.add( mainLight );
				// mainLight.shadow.mapSize = new THREE.Vector2(512,512);

				var spotLight = new THREE.SpotLight( 0x666666, 2 );
				spotLight.penumbra = 0.04;
				spotLight.angle = Math.PI/4;
				// spotLight.decay = 1;
				spotLight.position.set( 0, roomHeight/1.2, roomlength/2.2 );
				spotLight.target.position.set( 0, 0, roomlength/2.2 );
				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 512;
				spotLight.shadow.mapSize.height = 512;

				spotLight.shadow.camera.near = 10;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;
				// scene.add( spotLight );

				var spotLight = new THREE.SpotLight( 0x666666, 2 );
				spotLight.angle = Math.PI/2.5;
				spotLight.penumbra = 0.04;
				// spotLight.decay = 1;
				spotLight.position.set( 0, roomHeight/1, 0 );
				spotLight.target.position.set( 0, 0, 0 );
				spotLight.castShadow = true;
				spotLight.shadow.bias = -0.001;

				spotLight.shadow.mapSize.width = 512;
				spotLight.shadow.mapSize.height = 512;

				spotLight.shadow.camera.near = 10;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;
				// spotLight.shadow.radius = 6;

				scene.add( spotLight );
				progressiveShadowPass.addLight(spotLight);
				specialMaterial.uniforms["lightPosition"].value = (spotLight.position);
				filteredESM = new FilteredESM(scene, camera, spotLight);


				var greenLight = new THREE.PointLight( 0xcccccc, 1.0, 200, 1.5 );
				greenLight.position.y = roomHeight/1.2;
				greenLight.position.x = roomwidth/3;
				// scene.add( greenLight );

				// var redLight = new THREE.PointLight( 0xff0000, 0.25, 1000 );
				// redLight.position.set( - 550, 50, 0 );
				// scene.add( redLight );

				var blueLight = new THREE.PointLight( 0xcccccc, 1.0, 200, 1.5 );
				blueLight.position.y = roomHeight/1.2;
				blueLight.position.x = -roomwidth/3;
				// scene.add( blueLight );


				cubeCamera = new THREE.CubeCamera( 1, 100000, 256 );
				scene.add( cubeCamera );

			}
			var frameCount = 0;
			var temp = 0;

			function perturbProjectionMatrix ( sampleNumber ) {
		    var projectionMatrix = camera.projectionMatrix;
		    var sample;
		    var N = sampleNumber;
		    N = sampleNumber % (supersamplePositions.length);
		    sample = supersamplePositions[N];

		    var w = window.innerWidth; var h = window.innerHeight;
		    // sample.x = 0.5*Math.random() - 0.5;
		    // sample.y = 0.5*Math.random() - 0.5;
				var scale = 0.5;
				var x = (2*sample.x-1) * scale;
				var y = (2*sample.y-1) * scale;
				var theta = Math.random() * 2 * Math.PI;
				var temp = x * Math.cos(theta) + Math.sin(theta) * y;
				y = x * -Math.sin(theta) + Math.cos(theta) * y;
				x = temp;
		    camera.setViewOffset(w, h, x, y, w, h);
		  }

			function render() {

				// if( temp > 100)
				// 	return;
				// temp++;
				if(!allLoaded)
					return;
				saoPass.render( renderer );
				// progressiveShadowPass.render( renderer );
				filteredESM.render( renderer );
				// plane.material.map = saoPass.getSAOBuffer().texture;
				// specialMaterial.uniforms["shadowBuffer"].value = progressiveShadowPass.getShadowBuffer().texture;
				// specialMaterial.uniforms["shadowBuffer"].value = filteredESM.getShadowBuffer().texture;
				// specialMaterial.uniforms["saoBuffer"].value = saoPass.getSAOBuffer().texture;
				// renderer.render(this.sceneOrtho, this.orthoCamera);

				// return;
				if(frameCount >= 150)
					perturbProjectionMatrix(frameCount-150);

				frameCount++;
				// renderer.render(scene, camera);
				composer.render();

				if ( updateCount < 3 && allLoaded ) {
					probes = [];
					// boxMesh1.visible = false;
					for( var i=0; i<numProbes; i++ ) {
						cubeCamera.position.copy( probePositions[i] );
						renderer.autoClear = false;
						cubeCamera.updateCubeMap( renderer, scene );
						updateCubemap = false;
						var cubeMap = cubeCamera.renderTarget;
						cubeMap.encoding = THREE.LinearEncoding;

						var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
						pmremGenerator.update( renderer );

						var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
						pmremCubeUVPacker.update( renderer );

						probes.push(pmremCubeUVPacker.CubeUVRenderTarget.texture);
					}
					// cubeCamera.position.copy( probePosition1 );
					// renderer.autoClear = true;
					// cubeCamera.updateCubeMap( renderer, scene );
					// updateCubemap = false;
					// var cubeMap = cubeCamera.renderTarget;
					// cubeMap.encoding = THREE.LinearEncoding;
					//
					// var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
					// pmremGenerator.update( renderer );
					//
					// var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
					// pmremCubeUVPacker.update( renderer );

					if(updateCount == 2) {
						var radius = 10;
						var x = -0; var dx = 2*radius + 10;
						for( var i=0; i<1; i++ ) {
							// var geometry = new THREE.SphereGeometry( radius, 32, 32 );
							// var material = new THREE.MeshStandardMaterial( {color: 0x110000, metalness:0.0, roughness:0.0, envMap:probes[0] } );
							// var sphere = new THREE.Mesh( geometry, material );
							// sphere.material.envMap = probes[0];
							// sphere.material.envMapProbe1 = probes[0];
							// sphere.material.metalness = 0;
							// sphere.material.roughness = i/4;
							// sphere.position.copy(new THREE.Vector3(30, 20, 0));
							// scene.add( sphere );
							// sphere.castShadow = true;
							// sphere.position.x = x;
							// sphere.receiveShadow = true;
							// x += dx;
						}
					}

					planeBottom.material.envMap = probes[0];
					planeBottom.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeBottom.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeBottom.material.needsUpdate = true;
					planeBottom.material.metalness = 0;
					planeBottom.material.roughness = 0.0;

					planeTop.material.envMap = probes[0];
					planeTop.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeTop.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeTop.material.needsUpdate = true;

					planeFront.material.envMap = probes[0];
					planeFront.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeFront.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeFront.material.needsUpdate = true;
					planeFront.material.metalness = 0;

					planeBack.material.envMap = probes[0];
					planeBack.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeBack.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeBack.material.needsUpdate = true;
					planeBack.material.metalness = 0;

					planeLeft.material.envMap = probes[0];
					planeLeft.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeLeft.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeLeft.material.needsUpdate = true;
					planeLeft.material.metalness = 0;

					planeRight.material.envMap = probes[0];
					planeRight.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					planeRight.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					planeRight.material.needsUpdate = true;
					planeRight.material.metalness = 0;

					boxMesh1.material.envMap = probes[0];
					boxMesh1.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					boxMesh1.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					boxMesh1.material.needsUpdate = true;

					graniteMesh1.material.envMap = probes[0];
					graniteMesh1.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					graniteMesh1.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					graniteMesh1.material.needsUpdate = true;

					boxMesh2.material.envMap = probes[0];
					boxMesh2.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					boxMesh2.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					boxMesh2.material.needsUpdate = true;

					graniteMesh2.material.envMap = probes[0];
					graniteMesh2.material.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					graniteMesh2.material.envMapProbe2 = saoPass.getSAOBuffer().texture;
					graniteMesh2.material.needsUpdate = true;

					for( var i=0; i<graniteMeshes.length; i++) {
						graniteMaterial.envMap = probes[0];
						graniteMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
						graniteMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
						graniteMaterial.needsUpdate = true;
						graniteMeshes[i].material = graniteMaterial;
						var texture = graniteMaterial.map;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4 );
					}
					for( var i=0; i<shMeshes.length; i++) {
						shMaterial.envMap = probes[0];
						shMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
						shMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
						shMaterial.needsUpdate = true;
						shMeshes[i].material = shMaterial;
					}
					for( var i=0; i<handleMeshes.length; i++) {
						handleMaterial.envMap = probes[0];
						handleMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
						handleMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
						handleMaterial.needsUpdate = true;
						handleMeshes[i].material = handleMaterial;
					}
					for( var i=0; i<skirtMeshes.length; i++) {
						skirtMaterial.envMap = probes[0];
						skirtMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
						skirtMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
						skirtMaterial.needsUpdate = true;
						skirtMeshes[i].material = skirtMaterial;
					}
					for( var i=0; i<carMeshes.length; i++) {
						carMaterial.envMap = probes[0];
						carMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
						carMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
						carMaterial.needsUpdate = true;
						carMeshes[i].material = carMaterial;
					}
					hobBlackMaterial.envMap = probes[0];
					hobBlackMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					hobBlackMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					hobBlackMaterial.needsUpdate = true;
					hobBlackMesh.material = hobBlackMaterial;

					hobChromeMaterial.envMap = probes[0];
					hobChromeMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					hobChromeMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					hobChromeMaterial.needsUpdate = true;
					hobChromeMesh.material = hobChromeMaterial;

					sinkMaterial.envMap = probes[0];
					sinkMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					sinkMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					sinkMaterial.needsUpdate = true;
					sinkMesh.material = sinkMaterial;

					chimneyBlackMaterial.envMap = probes[0];
					chimneyBlackMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					chimneyBlackMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					chimneyBlackMaterial.needsUpdate = true;
					chimneyBlackMesh.material = chimneyBlackMaterial;

					chimneyChromeMaterial.envMap = probes[0];
					chimneyChromeMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					chimneyChromeMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					chimneyChromeMaterial.needsUpdate = true;
					chimneyChromeMesh.material = chimneyChromeMaterial;

					toolMaterial.envMap = probes[0];
					toolMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					toolMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					toolMaterial.needsUpdate = true;

					bowlMaterial.envMap = probes[0];
					bowlMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					bowlMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					bowlMaterial.needsUpdate = true;

					for( var i=0; i<toolMeshes.length; i++) {
						toolMeshes[i].material = toolMaterial;
						toolMeshes[i].material.needsUpdate = true;
						toolMeshes[i].envMapProbe1 = filteredESM.getShadowBuffer().texture;
						toolMeshes[i].envMapProbe2 = saoPass.getSAOBuffer().texture;
					}
					for( var i=0; i<bowlSetMeshes.length; i++) {
						bowlSetMeshes[i].material = bowlMaterial;
						bowlSetMeshes[i].material.needsUpdate = true;
						bowlSetMeshes[i].envMapProbe1 = filteredESM.getShadowBuffer().texture;
						bowlSetMeshes[i].envMapProbe2 = saoPass.getSAOBuffer().texture;
					}
					for( var i=0; i<plateSetMeshes.length; i++) {
						plateSetMeshes[i].material = bowlMaterial;
						plateSetMeshes[i].material.needsUpdate = true;
						plateSetMeshes[i].envMapProbe1 = filteredESM.getShadowBuffer().texture;
						plateSetMeshes[i].envMapProbe2 = saoPass.getSAOBuffer().texture;
					}
					// boxMesh2.material.envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;
					// boxMesh2.material.needsUpdate = true;
					boxMesh1.visible = true;

					for( var i=0; i<sphMeshes.length; i++) {
						sphMeshes[i].envMap = probes[0];
						sphMeshes[i].envMapProbe1 = filteredESM.getShadowBuffer().texture;
						sphMeshes[i].envMapProbe2 = saoPass.getSAOBuffer().texture;
						sphMeshes[i].material = planeFront.material;
						sphMeshes[i].material.needsUpdate = true;
					}
					//
					sofaMaterial.envMap = probes[0];
					sofaMaterial.envMapProbe1 = filteredESM.getShadowBuffer().texture;
					sofaMaterial.envMapProbe2 = saoPass.getSAOBuffer().texture;
					sofaMaterial.needsUpdate = true;

					updateCount++;
				}
				// camera.clearViewOffset();

			}

			function update() {

				requestAnimationFrame( update );

				var timer = Date.now() * 0.01;

				cameraControls.update();

				render();

				stats.update();
			}

			init();
			fillScene();
			update();

		</script>
	</body>
</html>
