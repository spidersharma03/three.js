<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #888888;
				font-family:Monospace;
				font-size:13px;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px;
				width: 200px;
				left: calc(50% - 100px);
				text-align: center;
			}

			a {
				color: #00f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - mirror
		</div>

		<script src="../build/three.js"></script>
		<script src="../examples/js/libs/stats.min.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/FlyControls.js"></script>
		<script src="js/pmrem/PMREMGenerator.js"></script>
		<script src="js/pmrem/PMREMCubeUVPacker.js"></script>

		<script>

		var stats = new Stats();
		stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
		document.body.appendChild( stats.dom );
			// scene size
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			// camera
			var VIEW_ANGLE = 45;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 1;
			var FAR = 500;

			var camera, scene, renderer;
			var numProbes = 1;
			var probePositions = [new THREE.Vector3(0, 40, 0), new THREE.Vector3(0, 45, 0)];
			var probes = [];

			var cubeCamera;
			var updateCubemap = true;
			var updateCount = 0;
			var planeLeft, planeRight, planeTop, planeBottom, planeBack, planeFront;
			var boxMesh1, boxMesh2;
			var graniteMesh1, graniteMesh2;
			var graniteMeshes = [];
			var shMeshes = [];
			var handleMeshes = [];
			var skirtMeshes = [];
			var hobBlackMesh, hobChromeMesh;
			var sinkMesh;

			var carMeshes = [];
			var chimneyBlackMesh, chimneyChromeMesh;

			var graniteMaterial;
			var shMaterial;
			var handleMaterial;
			var skirtMaterial;
			var hobBlackMaterial, hobChromeMaterial;
			var sinkMaterial;

			var carMaterial;
			var chimneyBlackMaterial, chimneyChromeMaterial;

			var rootNode = new THREE.Object3D();

			var cameraControls;

			var verticalMirror, groundMirror;
			var sphereGroup, smallSphere;
			var allLoaded = false;
			var roughnessMap;

			var manager = new THREE.LoadingManager();
			manager.onProgress = function ( item, loaded, total ) {
				console.log( item, loaded, total );
			};

			manager.onLoad = function ( ) {
				console.log( "All Items Loaded" );
				allLoaded = true;
			};

			var modelLoader = new THREE.OBJLoader();

			function init() {

				// renderer
				renderer = new THREE.WebGLRenderer({antialias : true});
				renderer.shadowMap.type = THREE.PCSSSoftShadowMap;
				renderer.shadowMap.enabled = true;
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );
				renderer.setClearColor(0xeeeeff);
				// scene
				scene = new THREE.Scene();
				scene.add(rootNode);
				loadModels();
				// camera
				camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
				camera.position.set( 0, 75, 160 );

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 40, 0);
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.update();

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

			}

			function IdentifyAndAddMeshes(mesh) {
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				IdentifyAndAddGraniteTopMeshes(mesh);
				IdentifyAndAddSHMeshes(mesh);
				IdentifyAndAddHandleMeshes(mesh);
				IdentifyAndAddSkirtMeshes(mesh);
				IdentifyAndAddHobMeshes(mesh);
				IdentifyAndAddSinkMesh(mesh);

				IdentifyAndAddCarMeshes(mesh);
				IdentifyAndAddChimneyMeshes(mesh);
			}

			function IdentifyAndAddGraniteTopMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("ctop") ) {
					graniteMeshes.push(mesh);
				}
			}

			function IdentifyAndAddSHMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_sh_") || name.includes("_dr_") ) {
					shMeshes.push(mesh);
				}
			}

			function IdentifyAndAddCarMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_car") || name.includes("_cur") ) {
					carMeshes.push(mesh);
				}
			}

			function IdentifyAndAddChimneyMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_chimneyblack") ) {
					chimneyBlackMesh = mesh;
				}
				if( name.includes("_chimney_chrome") ) {
					chimneyChromeMesh = mesh;
				}
			}

			function IdentifyAndAddHandleMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_handle_") ) {
					handleMeshes.push(mesh);
				}
			}

			function IdentifyAndAddSkirtMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_skirt_") || name.includes("_skirting_") ) {
					skirtMeshes.push(mesh);
				}
			}

			function IdentifyAndAddHobMeshes(mesh) {
				var name = mesh.name;
				if( name.includes("_hob_black") ) {
					hobBlackMesh = mesh;
				}
				if( name.includes("_hob_chrome") ) {
					hobChromeMesh = mesh;
				}
			}

			function IdentifyAndAddSinkMesh(mesh) {
				var name = mesh.name;
				if( name.includes("_sink_") ) {
					sinkMesh = mesh;
				}
			}

			function loadModels() {
				rootNode.position.x = 44;
				rootNode.position.z = 0.2;

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_clean_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_clean_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_consumable_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_consumable_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_cook_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_cook_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_non consumable_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_non consumable_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_prep_bottom.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);

				modelLoader.load(
					'models/obj/Model_KitchenLShape/com_m_prep_top.obj',
					function ( object ) {
						rootNode.add( object );
						object.traverse( IdentifyAndAddMeshes );
					}
				);
			}

			function fillScene() {

				var planeGeo = new THREE.PlaneBufferGeometry( 1.0, 1.0 );

				var loader = new THREE.TextureLoader(manager);
			  roughnessMap = loader.load("textures/roughness_map.jpg");
			  var wallTexture1 = loader.load("textures/kitchen_tile2.jpg");
				wallTexture1.wrapS = THREE.RepeatWrapping;
				wallTexture1.wrapT = THREE.RepeatWrapping;
				var wallTexture2 = loader.load("textures/5096.jpg");
				var floorTexture = loader.load("textures/kitchen-tile-texture-seamless.jpg");
				var wallTexture3 = loader.load("textures/Pink wall paint stucco plaster texture tileable.jpg");
				var ceilingTexture = loader.load("textures/tilable_wall.jpg");
				var graniteTexture = loader.load("textures/granite.jpg");
				// var graniteTexture = loader.load("textures/marble-tiles-500x500.jpg");
				var cupboardTexture = loader.load("textures/Hickory.jpg");

				floorTexture.wrapS = THREE.RepeatWrapping;
				floorTexture.wrapT = THREE.RepeatWrapping;
				floorTexture.repeat.set( 3, 2 );
				floorTexture.anisotropy = 4;

				wallTexture2.wrapS = THREE.RepeatWrapping;
				wallTexture2.wrapT = THREE.RepeatWrapping;
				wallTexture2.repeat.set( 3, 2 );

				wallTexture3.wrapS = THREE.RepeatWrapping;
				wallTexture3.wrapT = THREE.RepeatWrapping;
				wallTexture3.repeat.set( 3, 2 );

				ceilingTexture.wrapS = THREE.RepeatWrapping;
				ceilingTexture.wrapT = THREE.RepeatWrapping;
				ceilingTexture.repeat.set( 4.5, 3 );

				// walls
				var roomwidth = 132;
				var roomlength = 118.5;
				var roomHeight = 100;

				graniteTexture.wrapS = THREE.RepeatWrapping;
				graniteTexture.wrapT = THREE.RepeatWrapping;
				graniteTexture.repeat.set( 6, 1 );

				cupboardTexture.wrapS = THREE.RepeatWrapping;
				cupboardTexture.wrapT = THREE.RepeatWrapping;
				cupboardTexture.repeat.set( 6, 1 );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;

				wallTexture1.repeat.set( 3 * roomwidth/roomlength, 3 );

			  planeTop = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap:ceilingTexture, metalness:0.0, bumpScale:0.1, roughness:0.75 } ) );
				planeTop.position.y = roomHeight;
				// planeTop.position.x = roomHeight/1;
				planeTop.rotateX( Math.PI / 2 );
				planeTop.scale.x = roomwidth;
				planeTop.scale.y = roomlength;
				planeTop.castShadow = true;
				planeTop.receiveShadow = true;
				scene.add( planeTop );

			  planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map: floorTexture, bumpMap: floorTexture, bumpScale:0.1, roughness: 0.2 } ) );
				planeBottom.position.y = 0;
				planeBottom.rotateX( -Math.PI / 2 );
				planeBottom.scale.x = roomwidth;
				planeBottom.scale.y = roomlength;
				scene.add( planeBottom );
				planeBottom.castShadow = true;
				planeBottom.receiveShadow = true;

			  planeBack = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:wallTexture1, bumpMap:wallTexture1, bumpScale:0.001, roughness: 0.01} ) );
				planeBack.position.z = -roomlength/2;
				planeBack.position.y = roomHeight/2;
				planeBack.scale.x = roomwidth;
				planeBack.scale.y = roomHeight;
				planeBack.castShadow = true;
				planeBack.receiveShadow = true;
				// planeBack.material.side = THREE.DoubleSide;
				scene.add( planeBack );

			  planeFront = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:wallTexture1, bumpMap:wallTexture1, bumpScale:0.1, roughness: 0.1 } ) );
				planeFront.position.z = roomlength/2;
				planeFront.position.y = roomHeight/2;
				planeFront.rotateY( Math.PI );
				planeFront.scale.x = roomwidth;
				planeFront.scale.y = roomHeight;
				planeFront.castShadow = true;
				planeFront.receiveShadow = true;
				scene.add( planeFront );

			  planeRight = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap: ceilingTexture, bumpScale:0.03, roughness:0.75 } ) );
				planeRight.position.x = roomwidth/2;
				planeRight.position.y = roomHeight/2;
				planeRight.rotateY( - Math.PI / 2 );
				planeRight.scale.x = roomlength;
				planeRight.scale.y = roomHeight;
				planeRight.castShadow = true;
				planeRight.receiveShadow = true;
				scene.add( planeRight );

			  planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshStandardMaterial( { color: 0xffffff, map:ceilingTexture, bumpMap: ceilingTexture, bumpScale:0.03,roughness:0.75  } ) );
				planeLeft.position.x = -roomwidth/2;
				planeLeft.position.y = roomHeight/2;
				planeLeft.rotateY( Math.PI / 2 );
				planeLeft.scale.x = roomlength;
				planeLeft.scale.y = roomHeight;
				planeLeft.castShadow = true;
				planeLeft.receiveShadow = true;
				// planeLeft.material.side = THREE.DoubleSide;
				scene.add( planeLeft );

				var graniteThickness = 2;
				var graniteWidth = 24.1;
				var boxHeight = 32.5;
				var boxGeometry = new THREE.BoxGeometry(roomwidth, 23.5, 14 );
				boxMesh1 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0x330000, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2  } ) );
				boxMesh1.position.z = -52.5;
				boxMesh1.position.y = 67;
				boxMesh1.castShadow = true;
				boxMesh1.receiveShadow = true;
				// scene.add( boxMesh1 );

				var boxGeometry = new THREE.BoxGeometry(roomwidth, graniteThickness, graniteWidth );
				graniteMesh1 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05  } ) );
				graniteMesh1.position.z = -roomlength/2 + graniteWidth/2;
				graniteMesh1.position.y = (boxHeight - graniteThickness) + graniteThickness/2;
				graniteMesh1.castShadow = true;
				graniteMesh1.receiveShadow = true;
				// scene.add( graniteMesh1 );

				var boxGeometry = new THREE.BoxGeometry(roomlength, boxHeight - graniteThickness, graniteWidth );
				boxMesh2 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0x330000, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2  } ) );
				boxMesh2.position.y = (boxHeight - graniteThickness)/2;
				boxMesh2.rotation.y = Math.PI/2;
				boxMesh2.position.x = -roomwidth/2 + graniteWidth/2;
				boxMesh2.position.z = 0;
				// scene.add( boxMesh2 );

				var boxGeometry = new THREE.BoxGeometry(roomlength, graniteThickness, graniteWidth );
				graniteMesh2 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05  } ) );
				graniteMesh2.rotation.y = Math.PI/2;
				graniteMesh2.position.x = -roomwidth/2 + graniteWidth/2;
				graniteMesh2.position.y = (boxHeight - graniteThickness) + graniteThickness/2;
				graniteMesh2.position.z = 0;
				// scene.add( graniteMesh2 );

			  graniteMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:graniteTexture, bumpMap: graniteTexture, bumpScale:0.01, roughness:0.05, metalness:0.0  } );
				shMaterial = new THREE.MeshStandardMaterial( { color: 0x663311, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness:0.0  } );
				handleMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.1, metalness: 1.0  } );
				skirtMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: graniteTexture, bumpScale:0.30, roughness:0.95, metalness: 0.0  } );
				hobBlackMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: null, bumpScale:0.0, roughness:0.05, metalness: 0.0  } );
				hobChromeMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness: 1.0  } );
				sinkMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness: 1.0  } );

				carMaterial = new THREE.MeshStandardMaterial( { color: 0xaaaaaa, metalness:0,map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness:0.0  } );
				chimneyBlackMaterial = new THREE.MeshStandardMaterial( { color: 0x000000, map:null, bumpMap: null, bumpScale:0.0, roughness:0.05, metalness: 0.0  } );
				chimneyChromeMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map:null, bumpMap: null, bumpScale:0.0, roughness:0.2, metalness: 1.0  } );

				// var boxHeight = roomHeight/4;
				// var boxWidth = roomHeight/4;
				// var boxGeometry = new THREE.BoxGeometry(roomwidth, boxHeight, graniteWidth );
				// boxMesh3 = new THREE.Mesh( boxGeometry, new THREE.MeshStandardMaterial( { color: 0xffffff, map:cupboardTexture, bumpScale:0.0, roughness:0.0  } ) );
				// boxMesh3.position.z = -roomlength/2 + graniteWidth/2;
				// boxMesh3.position.y = boxHeight/2;
				// boxMesh3.castShadow = true;
				// boxMesh3.receiveShadow = true;
				// // scene.add( boxMesh3 );

				// lights
				var mainLight = new THREE.SpotLight( 0xcccccc, 0.5, 200, 1.5 );
				mainLight.castShadow = true;
				mainLight.position.y = 1*roomHeight/1.5;
				// mainLight.position.z = 1*roomlength/1.2;
				// scene.add( mainLight );
				// mainLight.shadow.mapSize = new THREE.Vector2(512,512);

				var spotLight = new THREE.SpotLight( 0x666666, 2 );
				spotLight.penumbra = 0.04;
				spotLight.angle = Math.PI/4;
				// spotLight.decay = 1;
				spotLight.position.set( 0, roomHeight/1.2, roomlength/2.2 );
				spotLight.target.position.set( 0, 0, roomlength/2.2 );
				spotLight.castShadow = true;

				spotLight.shadow.mapSize.width = 512;
				spotLight.shadow.mapSize.height = 512;

				spotLight.shadow.camera.near = 10;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;
				// scene.add( spotLight );

				var spotLight = new THREE.SpotLight( 0x666666, 2 );
				spotLight.angle = Math.PI/3;
				spotLight.penumbra = 0.04;
				// spotLight.decay = 1;
				spotLight.position.set( 40, 1, 0 );
				spotLight.target.position.set( 40, roomHeight, 0 );
				spotLight.castShadow = true;
				spotLight.shadow.bias = 0.0005;

				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;

				spotLight.shadow.camera.near = 10;
				spotLight.shadow.camera.far = 4000;
				spotLight.shadow.camera.fov = 30;
				spotLight.shadow.radius = 6;

				scene.add( spotLight );

				var greenLight = new THREE.PointLight( 0xcccccc, 1.0, 200, 1.5 );
				greenLight.position.y = roomHeight/1.2;
				greenLight.position.x = roomwidth/3;
				// scene.add( greenLight );

				// var redLight = new THREE.PointLight( 0xff0000, 0.25, 1000 );
				// redLight.position.set( - 550, 50, 0 );
				// scene.add( redLight );

				var blueLight = new THREE.PointLight( 0xcccccc, 1.0, 200, 1.5 );
				blueLight.position.y = roomHeight/1.2;
				blueLight.position.x = -roomwidth/3;
				// scene.add( blueLight );


				cubeCamera = new THREE.CubeCamera( 1, 100000, 256 );
				scene.add( cubeCamera );

			}

			function render() {

				renderer.render(scene, camera);

				if ( updateCount < 3 && allLoaded ) {
					probes = [];
					// boxMesh1.visible = false;
					for( var i=0; i<numProbes; i++ ) {
						cubeCamera.position.copy( probePositions[i] );
						renderer.autoClear = true;
						cubeCamera.updateCubeMap( renderer, scene );
						updateCubemap = false;
						var cubeMap = cubeCamera.renderTarget;
						cubeMap.encoding = THREE.LinearEncoding;

						var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
						pmremGenerator.update( renderer );

						var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
						pmremCubeUVPacker.update( renderer );

						probes.push(pmremCubeUVPacker.CubeUVRenderTarget.texture);
					}
					// cubeCamera.position.copy( probePosition1 );
					// renderer.autoClear = true;
					// cubeCamera.updateCubeMap( renderer, scene );
					// updateCubemap = false;
					// var cubeMap = cubeCamera.renderTarget;
					// cubeMap.encoding = THREE.LinearEncoding;
					//
					// var pmremGenerator = new THREE.PMREMGenerator( cubeMap );
					// pmremGenerator.update( renderer );
					//
					// var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
					// pmremCubeUVPacker.update( renderer );

					if(updateCount == 2) {
						var radius = 10;
						var x = -0; var dx = 2*radius + 10;
						for( var i=0; i<1; i++ ) {
							// var geometry = new THREE.SphereGeometry( radius, 32, 32 );
							// var material = new THREE.MeshStandardMaterial( {color: 0x110000, metalness:0.0, roughness:0.0, envMap:probes[0] } );
							// var sphere = new THREE.Mesh( geometry, material );
							// sphere.material.envMap = probes[0];
							// sphere.material.envMapProbe1 = probes[0];
							// sphere.material.metalness = 0;
							// sphere.material.roughness = i/4;
							// sphere.position.copy(new THREE.Vector3(30, 20, 0));
							// scene.add( sphere );
							// sphere.castShadow = true;
							// sphere.position.x = x;
							// sphere.receiveShadow = true;
							// x += dx;
						}
					}

					planeBottom.material.envMap = probes[0];
					planeBottom.material.envMapProbe1 = probes[1];
					planeBottom.material.needsUpdate = true;
					planeBottom.material.metalness = 0;
					planeBottom.material.roughness = 0.0;

					planeTop.material.envMap = probes[0];
					planeTop.material.envMapProbe1 = probes[1];
					planeTop.material.needsUpdate = true;

					planeFront.material.envMap = probes[0];
					planeFront.material.envMapProbe1 = probes[1];
					planeFront.material.needsUpdate = true;
					planeFront.material.metalness = 0;

					planeBack.material.envMap = probes[0];
					planeBack.material.envMapProbe1 = probes[1];
					planeBack.material.needsUpdate = true;
					planeBack.material.metalness = 0;

					planeLeft.material.envMap = probes[0];
					planeLeft.material.envMapProbe1 = probes[1];
					planeLeft.material.needsUpdate = true;
					planeLeft.material.metalness = 0;

					planeRight.material.envMap = probes[0];
					planeRight.material.envMapProbe1 = probes[1];
					planeRight.material.needsUpdate = true;
					planeRight.material.metalness = 0;

					boxMesh1.material.envMap = probes[0];
					boxMesh1.material.envMapProbe1 = probes[1];
					boxMesh1.material.needsUpdate = true;

					graniteMesh1.material.envMap = probes[0];
					graniteMesh1.material.envMapProbe1 = probes[1];
					graniteMesh1.material.needsUpdate = true;

					boxMesh2.material.envMap = probes[0];
					boxMesh2.material.envMapProbe1 = probes[1];
					boxMesh2.material.needsUpdate = true;

					graniteMesh2.material.envMap = probes[0];
					graniteMesh2.material.envMapProbe1 = probes[1];
					graniteMesh2.material.needsUpdate = true;

					for( var i=0; i<graniteMeshes.length; i++) {
						graniteMaterial.envMap = probes[0];
						graniteMaterial.envMapProbe1 = probes[1];
						graniteMaterial.needsUpdate = true;
						graniteMeshes[i].material = graniteMaterial;
						var texture = graniteMaterial.map;
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.repeat.set( 4, 4 );
					}
					for( var i=0; i<shMeshes.length; i++) {
						shMaterial.envMap = probes[0];
						shMaterial.envMapProbe1 = probes[1];
						shMaterial.needsUpdate = true;
						shMeshes[i].material = shMaterial;
					}
					for( var i=0; i<handleMeshes.length; i++) {
						handleMaterial.envMap = probes[0];
						handleMaterial.envMapProbe1 = probes[1];
						handleMaterial.needsUpdate = true;
						handleMeshes[i].material = handleMaterial;
					}
					for( var i=0; i<skirtMeshes.length; i++) {
						skirtMaterial.envMap = probes[0];
						skirtMaterial.envMapProbe1 = probes[1];
						skirtMaterial.needsUpdate = true;
						skirtMeshes[i].material = skirtMaterial;
					}
					for( var i=0; i<carMeshes.length; i++) {
						carMaterial.envMap = probes[0];
						carMaterial.envMapProbe1 = probes[1];
						carMaterial.needsUpdate = true;
						carMeshes[i].material = carMaterial;
					}
					hobBlackMaterial.envMap = probes[0];
					hobBlackMaterial.envMapProbe1 = probes[1];
					hobBlackMaterial.needsUpdate = true;
					hobBlackMesh.material = hobBlackMaterial;

					hobChromeMaterial.envMap = probes[0];
					hobChromeMaterial.envMapProbe1 = probes[1];
					hobChromeMaterial.needsUpdate = true;
					hobChromeMesh.material = hobChromeMaterial;

					sinkMaterial.envMap = probes[0];
					sinkMaterial.envMapProbe1 = probes[1];
					sinkMaterial.needsUpdate = true;
					sinkMesh.material = sinkMaterial;

					chimneyBlackMaterial.envMap = probes[0];
					chimneyBlackMaterial.envMapProbe1 = probes[1];
					chimneyBlackMaterial.needsUpdate = true;
					chimneyBlackMesh.material = chimneyBlackMaterial;

					chimneyChromeMaterial.envMap = probes[0];
					chimneyChromeMaterial.envMapProbe1 = probes[1];
					chimneyChromeMaterial.needsUpdate = true;
					chimneyChromeMesh.material = chimneyChromeMaterial;
					// boxMesh2.material.envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;
					// boxMesh2.material.needsUpdate = true;
					boxMesh1.visible = true;
					updateCount++;
				}

			}

			function update() {

				requestAnimationFrame( update );

				var timer = Date.now() * 0.01;

				cameraControls.update();

				render();

				stats.update();
			}

			init();
			fillScene();
			update();

		</script>
	</body>
</html>
