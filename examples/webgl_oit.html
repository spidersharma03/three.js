<!DOCTYPE html>

<html lang="en">
	<head>
		<title>three.js webgl - oit </title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
			}

			a {
				color:#00ff78;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
			.dg.ac {
				z-index: 1 !important; /* FIX DAT.GUI */
			}
		</style>
	</head>
	<body>
		<script src="../build/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>

		<script src="js/Detector.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>

		<div id="info">
			<!-- <a href="http://threejs.org" target="_blank">three.js</a> - Outline Pass by <a href="http://eduperiment.com" target="_blank">Prashant Sharma</a> and <a href="https://clara.io" target="_blank">Ben Houston</a><br/><br/> -->
		</div>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, controls;
			var mesh, decal;
			var raycaster = new THREE.Raycaster();

			var mouse = new THREE.Vector2();
			var selectedObjects = [];

			var obj3d = new THREE.Object3D();

			var group = new THREE.Object3D();

			var params = {
				edgeStrength: 3.0,
				edgeGlow: 0.0,
				edgeThickness: 1.0,
				pulsePeriod: 0,
				rotate: false,
				usePatternTexture: false
			}

			// Init gui
			// var gui = new dat.GUI();
			// gui.add( params, "edgeStrength", 0.01, 10 ).onChange( function(value) {
	    //     outlinePass.edgeStrength = Number(value);
	    // });
			// gui.add( params, "edgeGlow", 0.0, 1 ).onChange( function(value) {
	    //     outlinePass.edgeGlow = Number(value);
	    // })
			// gui.add( params, "edgeThickness", 1, 4 ).onChange( function(value) {
	    //     outlinePass.edgeThickness = Number(value);
	    // })
			// gui.add( params, "pulsePeriod", 0.0, 5 ).onChange( function(value) {
	    //     outlinePass.pulsePeriod = Number(value);
	    // })
			// gui.add( params, "rotate" )
			// gui.add( params, "usePatternTexture" ).onChange( function(value) {
			// 	outlinePass.usePatternTexture = value;
	    // })
			// var Configuration=function(){
	    //         this.visibleEdgeColor = "#ffffff";
			// 				this.hiddenEdgeColor = "#190a05";
	    // };
	    // var conf = new Configuration();

	    // var controladorVisible = gui.addColor( conf, 'visibleEdgeColor');
			// var controladorHidden = gui.addColor( conf, 'hiddenEdgeColor');
	    // controladorVisible.onChange( function( colorValue  )
	    // {
	    //   //the return value by the chooser is like as: #ffff
	    //   colorValue=colorValue.replace( '#','' );
	    //   function hexToRgb(hex) {
	    //         var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    //         return result ? {
	    //             r: parseInt(result[1], 16),
	    //             g: parseInt(result[2], 16),
	    //             b: parseInt(result[3], 16)
	    //         } : null;
	    //     }
	    //   var rgba = hexToRgb(colorValue);
      //   var color = outlinePass.visibleEdgeColor;
      //   color.r = rgba.r/255;
      //   color.g = rgba.g/255;
      //   color.b = rgba.b/255;
	    // });

			// controladorHidden.onChange( function( colorValue  )
	    // {
	    //   //the return value by the chooser is like as: #ffff
	    //   colorValue=colorValue.replace( '#','' );
	    //   function hexToRgb(hex) {
	    //         var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    //         return result ? {
	    //             r: parseInt(result[1], 16),
	    //             g: parseInt(result[2], 16),
	    //             b: parseInt(result[3], 16)
	    //         } : null;
	    //     }
	    //   var rgba = hexToRgb(colorValue);
      //   var color = outlinePass.hiddenEdgeColor;
      //   color.r = rgba.r/255;
      //   color.g = rgba.g/255;
      //   color.b = rgba.b/255;
	    // });

			init();

			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var width = window.innerWidth || 1;
				var height = window.innerHeight || 1;
				var devicePixelRatio = window.devicePixelRatio || 1;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.transparency = THREE.OrderIndependentTransperancy;
				renderer.shadowMap.enabled = true;
				renderer.setClearColor( 0xa0a0a0 );
				renderer.setPixelRatio( 1 );
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
				camera.position.z = 4;
				camera.position.x = 0;

				scene = new THREE.Scene();
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;

				initScene2();
				stats = new Stats();
				container.appendChild( stats.dom );


				window.addEventListener( 'resize', onWindowResize, false );
				// renderer.gammaOutput = true;
				// renderer.gammaInput = true;
				// renderer.gammaFactor = 2.2;
			}

			function initScene2() {
				var light = new THREE.DirectionalLight( 0xddffdd, 2);
				light.position.z = 2;
				light.position.y = 2;
				light.position.x = 2;
				scene.add( light );

				var phongMaterial   = new THREE.MeshPhongMaterial({color: 0xff0000, side: THREE.DoubleSide, opacity: 0.75, transparent: true, shininess:50, premultipliedAlpha: false});
				var lambertMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, side: THREE.DoubleSide, opacity: 0.75, transparent: true, premultipliedAlpha: true});

				var planeGeometry = new THREE.PlaneBufferGeometry(2,2);
				// var planeGeometry = new THREE.TorusGeometry(1, 0.3,20,20);
				// var planeGeometry = new THREE.BoxGeometry(1, 1, 1);
				var material1 = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide, opacity: 0.25, transparent: true, premultipliedAlpha: false});
				var material2 = new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide, opacity: 0.25, transparent: true, premultipliedAlpha: false});
				var material3 = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide, opacity: 0.25, transparent: true, premultipliedAlpha: false});
				var planeMesh1 = new THREE.Mesh( planeGeometry, material1 );
				var planeMesh2 = new THREE.Mesh( planeGeometry, material2 );
				var planeMesh3 = new THREE.Mesh( planeGeometry, material3 );
				planeMesh1.position.z = 1.5;
				planeMesh2.position.z = 0;
				// planeMesh2.position.x = 0.5;
				planeMesh3.position.z = -1.5;

				// planeMesh1.rotation.y = -1.5;
				// planeMesh2.rotation.y = -1.5;
				// planeMesh3.rotation.y = -1.5;

				// planeMesh3.position.x = 1;
				group.add(planeMesh1);
				group.add(planeMesh2);
				group.add(planeMesh3);
				var material4 = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide});
				var planeGeometry = new THREE.PlaneBufferGeometry(8,8);
				var planeMesh4 = new THREE.Mesh( planeGeometry, material4 );
				planeMesh4.rotation.x = Math.PI/2;
				planeMesh4.position.y = -2;
				scene.add(planeMesh4);

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};
				// model
				var loader = new THREE.OBJLoader( manager );
				loader.load( 'models/obj/tree.obj', function ( object ) {
					var scale = 1.0;
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							child.geometry.center();
							child.geometry.computeBoundingSphere();
							scale = 0.2*child.geometry.boundingSphere.radius;
							child.material = phongMaterial;
							child.material.side = THREE.DoubleSide;
							child.receiveShadow = true;
							child.castShadow = true;
						}
					} );
					object.position.y = 1;
					object.scale.x /= scale;
					object.scale.y /= scale;
					object.scale.z /= scale;
					// group.add( object );
				} );
				scene.add(group);
			}

			function initScene1() {
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};
				// model
				var loader = new THREE.OBJLoader( manager );
				loader.load( 'models/obj/tree.obj', function ( object ) {
					var scale = 1.0;
					object.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							child.geometry.center();
							child.geometry.computeBoundingSphere();
							scale = 0.2*child.geometry.boundingSphere.radius;
							var phongMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0xaaffff, shininess: 5, transparent:false,opacity:0.9, premultipliedAlpha:true } );
							child.material = phongMaterial;
							child.material.side = THREE.DoubleSide;
							child.receiveShadow = true;
							child.castShadow = true;
						}
					} );
					object.position.y = 1;
					object.scale.x /= scale;
					object.scale.y /= scale;
					object.scale.z /= scale;
					obj3d.add( object );
				} );
				group.add(obj3d);


				scene.add( group );

				var light = new THREE.DirectionalLight( 0xddffdd, 0.4);
				light.position.z = 1;
				light.position.y = 1;
				light.position.x = 1;
				scene.add( light );
				light.castShadow = true;

				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				var d = 20;

				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;

				light.shadow.camera.far = 1000;

				var light2 = new THREE.DirectionalLight( 0xaadddd, 0.15 );
				light2.position.z = 1;
				light2.position.x = -1;
				light2.position.y = -1;
				scene.add( light2 );

				var light3 = new THREE.DirectionalLight( 0xddddaa, 0.1 );
				light3.position.z = 1;
				light3.position.x = -1;
				light3.position.y = 1;
				scene.add( light3 );

				var light3 = new THREE.AmbientLight( 0xaaaaaa, 0.2 );
				scene.add( light3 );

				var geometry = new THREE.SphereBufferGeometry( 3, 48, 24 );
				for ( var i = 0; i < 20; i ++ ) {

					var material = new THREE.MeshStandardMaterial({transparent:true, premultipliedAlpha:true});
					material.roughness = 0.5 * Math.random() + 0.25;
					material.metalness = 1.0;
					material.color.setHSL( Math.random(), 1.0, 0.3 );
					material.opacity = 1;//0.95 + Math.random() * 0.25;

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 4 - 2;
					mesh.position.y = Math.random() * 4 - 2;
					mesh.position.z = Math.random() * 4 - 2;
					mesh.rotation.x = Math.random();
					mesh.rotation.y = Math.random();
					mesh.rotation.z = Math.random();
					mesh.receiveShadow = true;
					mesh.castShadow = true;
					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.3 + 0.1;
					group.add( mesh );
				}

				var floorMaterial = new THREE.MeshLambertMaterial();
				floorMaterial.side = THREE.DoubleSide;
				material.roughness = 0.5 * Math.random() + 0.25;
				material.metalness = 0;

				var floorGeometry = new THREE.PlaneBufferGeometry( 12, 12 );
				var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.rotation.x -= Math.PI * 0.5;
				floorMesh.position.y -= 1.5;
				group.add( floorMesh );
				floorMesh.receiveShadow = true;

				var geometry = new THREE.TorusGeometry( 1, 0.3, 16, 100 );
				var material = new THREE.MeshPhongMaterial( { color: 0xffaaff } );
				var torus = new THREE.Mesh( geometry, material );
				torus.position.z = -4;
				group.add( torus );
				torus.receiveShadow = true;
				torus.castShadow = true;
			}

			function onWindowResize() {

				var width = window.innerWidth || 1;
				var height = window.innerHeight || 1;
				var devicePixelRatio = window.devicePixelRatio || 1;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
			}

			function animate() {

				requestAnimationFrame( animate );

				stats.begin();

				var timer = performance.now();
				if(params.rotate)
					group.rotation.y = timer * 0.0001;
				renderer.autoClear = true;
				renderer.setClearColor( 0xcfcfcf );
				renderer.setClearAlpha( 1.0 );
        renderer.render(scene, camera);
				controls.update();
				stats.end();
			}


		</script>
	</body>
</html>
